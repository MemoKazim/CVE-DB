# COPYRIGHT Informations

__author__ = "Ramin Mammadov, Nihad Goylarov, Toghrul Mustafali, Mahammadali Kazimov"
__copyright__ = "Copyright (C) 2024 Group E, CH3, AKM."
__license__ = "Public Domain"
__version__ = "1.0"


from lib.colors import bcolors
from lib.messages import *
from lib.output import *
from lib.scrap import *
import requests
import random
import time
import sys
import os
import re

# Clear Screen
if os.name == 'nt':
    os.system("cls")
else:
    os.system("clear")

# print(random.choice(banner))
print(banner[0])

# Retrive CVE from user. Do not trust user input.
user_input = input(f"{bcolors.FG_YELLOW}Enter CVE ID > {bcolors.END}").upper()

# Validate user input using regex
is_valid = re.search("^(CVE-)?[0-9]{4}-[0-9]*$", user_input) # If "CVE-" not written handle situaion 

# Validation process
if is_valid:
    # User input starts with "CVE-" string
    if is_valid.string.startswith("CVE-"):
        cve_full = is_valid.string

    # User input not starts with "CVE-" string
    else:
        cve_full = f"CVE-{is_valid.string}"

    # Check CVE year
    cve_year = int(cve_full.split("-")[1])

    # CVE year shoud be between 1999 - Current Year
    if cve_year > int(time.gmtime().tm_year) or cve_year < 1999:
        # Prints year out of scope message
        year_message = year_message.replace("YEAR", str(cve_year))
        print(year_message)
        sys.exit()
    
    # Check CVE id
    cve_id = cve_full.split("-")[2]
    if len(cve_id) < 4 or int(cve_id) == 0:
        id_message = id_message.replace("CVEID", cve_id)
        print(id_message)
        sys.exit()

# Bad input
else:
    usage_message = usage_message.replace("YEAR", str(time.gmtime().tm_year))
    print(usage_message)
    sys.exit()

# Validation Complated
    
# Create class of given cve in order to access it by typing attribute
class cve:
    full=cve_full
    year=cve_year
    id=cve_id


# Check whether CVE exists via API
def is_exists(cve):
    """
    Checks whether CVE exists by requesting mitre API

    Input: cve => String;
    Output: if status code is 200 => response | else 0;
    """
    URL = f"https://cveawg.mitre.org/api/cve-id/{cve}"
    response = requests.get(URL)
    if response.status_code == 200:
        return response
    else:
        return 0


# Check whether CVE is published
response = is_exists(cve.full)
if response:
    # Check whether CVE state is published?
    if response.json()["state"] != "PUBLISHED":
        cve_state_message = cve_state_message.replace("STATE", str(response.json()["state"])).replace("CVEID", cve.full)
        print(cve_state_message)
        sys.exit()

# If CVE does not exists print error message
else:
    cve_not_exist_message = cve_not_exist_message.replace("CVEID", cve.full)
    print(cve_not_exist_message)
    sys.exit()


print(f"\n{bcolors.FG_GREEN}[+] Following CVE exists and Published!{bcolors.END}")
# CVE exists and published!
# Get source input from user


# Enumerate Resources
SOURCES = {
    "1": nist,
    "2": exploitdb,
    "3": mitre,
    "4": vulners,
    "5": vulmon,
    "*": [nist, exploitdb, mitre, vulners, vulmon]
}

# Get input from user for Source request
sources = list(input(source_choice + f"\n{bcolors.FG_YELLOW}Choose source site > {bcolors.END}").split(","))
sources.sort()

# Check whether user input is in SOURCES dictionary
for source in sources:
    if source not in SOURCES.keys():
        source_message = source_message.replace("SOURCE", source)
        print(source_message)
        sys.exit()

# Call regarding function by user input
for source in sources:
    finished = False
    # In sorted list '*' char becomes first
    if source[0] == "*":
        for i in SOURCES["*"]:
            s = i.__name__
            scrap(s,i)
        break
    
    # Call regarding functions which are seperated by comma
    for i in source:
        s = SOURCES[i].__name__
        i = SOURCES[i]
        scrap(s,i)


# Check whether source contains exploit. If contains ask from user to download exploit
download_exploit = input(f"\n\n{bcolors.FG_YELLOW}Do you want to download exploit? (Y/n) > {bcolors.END}").lower().strip()

# Validate user input
while download_exploit not in ["y", "n", ""]:
    download_exploit = input(f"\b\r{bcolors.FG_YELLOW}Do you want to download exploit? (Y/n) > {bcolors.END}").lower().strip()

if download_exploit == "y" or "":
    print(f"{bcolors.FG_GREEN}[+] Exploit downloaded!{bcolors.END}")
    pass


# Enumerate output types
OUTPUTS = {
    "1": pdf,
    "2": html,
    "3": txt,
    "4": cli,
    "*": [pdf, html, txt, cli]
}

# Get input from user
output_type = list(input(f"{output_choice}\n{bcolors.FG_YELLOW}Choose output type> {bcolors.END}").split(","))
output_type.sort()

# Check whether user input is valid in OUTPUTS dictionary
for output in output_type:
    if output not in OUTPUTS.keys():
        output_message = output_message.replace("OUTPUT", output)
        print(output_message)
        sys.exit()

# Call regarding function which are in dictionary in order to generate output type
for output in output_type:
    # If user typed '*' char, call all output functions.
    if output[0] == "*":
        for i in OUTPUTS["*"]:
            s = i.__name__
            generate(s,i)
        break

    # Call regarding ouput functions which are seperated by comma in user input
    for i in output:
        s = OUTPUTS[i].__name__
        i = OUTPUTS[i]
        generate(s,i)

# Terminate code
sys.exit()